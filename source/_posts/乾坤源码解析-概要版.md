---
title: 乾坤源码解析-概要版
date: 2024-01-26 17:05:31
tags:
    - 微前端
---


## 乾坤源码解析 
### Single-Spa 痛点
single-spa就做了两件事 1. 加载微应用（加载方法还是用户自己提供的）2. 维护微应用状态（初始化、挂载、卸载）
主要的问题
1、对微应用的侵入性太强
	○ 微应用路由改造，添加一个特定的前缀
	○ 微应用入口改造，挂载点变更和生命周期函数导出
	○ 打包工具配置更改
2、样式隔离问题
3、JS 隔离
4、资源预加载
5、应用间通信
第一个和第四个就不好解决了，这是 JS Entry 方式带来的问题

<!-- more -->
### Qiankun由来
qiankun 基于 single-spa 做了二次封装，很好的解决了上面提到的几个问题

●	HTML Entry
       qiankun 通过 HTML Entry 的方式来解决 JS Entry 带来的问题，让你接入微应用像使用 iframe 一样简单。
●	样式隔离
qiankun 实现了两种样式隔离
○	严格的样式隔离模式，为每个微应用的容器包裹上一个 shadow dom 节点，从而确保微应用的样式不会对全局造成影响
○	实验性的方式，通过动态改写 css 选择器来实现，可以理解为 css scoped 的方式
●	运行时沙箱
        qiankun 的运行时沙箱分为 JS 沙箱和 样式沙箱
JS 沙箱 为每个微应用生成单独的 window proxy 对象，配合 HTML Entry 提供的 JS 脚本执行器 (execScripts) 来实现 JS 隔离；
样式沙箱 通过重写 DOM 操作方法，来劫持动态样式和 JS 脚本的添加，让样式和脚本添加到正确的地方，即主应用的插入到主应用模版内，微应用的插入到微应用模版，并且为劫持的动态样式做了 scoped css 的处理，为劫持的脚本做了 JS 隔离的处理
●	资源预加载
       qiankun 实现预加载的思路有两种，
一种是当主应用执行 start 方法启动 qiankun 以后立即去预加载微应用的静态资源
另一种是在第一个微应用挂载以后预加载其它微应用的静态资源，这个是利用 single-spa 提供的`single-spa:first-mount`事件来实现的
●	应用间通信
        qiankun 通过发布订阅模式来实现应用间通信，状态由框架来统一维护，每个应用在初始化时由框架生成一套通信方法，应用通过这些方法来更改全局状态和注册回调函数，全局状态发生改变时触发各个应用注册的回调函数执行，将新旧状态传递到所有应用

要了解乾坤原理 首先需要了解底层两个依赖逻辑原理
	一个是single-spa
	一个是html entry(由 import-html-entry库)实现
然后再看qiankun的源码部分，相对容易理解一些

### qiankun源码

#### 示例
qiankun提供了完整的项目示例 https://github.com/liyongning/qiankun
1.	git clone https://github.com/liyongning/qiankun.git
2.	yarn examples:install
3.	yarn examples:start   localhost:7099
qiankun提供的demo中 提供了两种主应用的实现方式(基于路由配置的 registerMicroApps 和 手动加载微应用的 loadMicroApp)，五种微应用的接入示例

### Q&A

#### qiankun样式隔离如何做的?

乾坤主要通过样式沙箱 通过增强 createElement 方法，负责创建元素并劫持 script、link、style 三个标签的创建动作；简单来说就是属于主应用的插入主应用，属于微应用的插入到对应的微应用中，方便微应用卸载的时候一起删除；
样式沙箱还额外做了两件事：
●	在卸载之前为动态添加样式做缓存
●	在微应用重新挂载时再插入到微应用内
将 proxy 对象传递给 execScripts 函数，将其设置为微应用的执行上下文
支持两种方式实现样式隔离 分别是shadow dom 和 scoped css
shadow dom为例
```js
registerMicoApp时 配置strictStyleIsolation 和sandbox选项，内部核心代码在createElement实现，通过shadow dom实现
主要步骤为 通过document.createElement('div')创建包裹容器原始dom，innerHTML赋值为appContent即编译后html模板，取出firstChild作为appElement，保存其innerHTML内容后清空innerHTML，检测支持attachShadow使用appElement.attachShadow({ mode: 'open' })作为shadow;否则使用 appElement.createShadowRoot()作为shadow; 最后把原始innerHTML赋值给  shadow.innerHTML
```
scoped css为例
```js
取出appInstanceId(初始化时被赋值)，取出所有style节点，遍历尽心scope处理
生成scope prefix  ${tag}[${QiankunCSSRewriteAttr}="${appName}"]  拿到样式表sheet cssRules
通过rewrite方法传递css和prefix, 通过给textContent赋值全新的css 
```
核心代码https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/css.ts

#### loadAPP作用

loadApp是乾坤的核心 主要干了以下几件事

1、通过 HTML Entry 的方式远程加载微应用，得到微应用的 html 模版（首屏内容）、JS 脚本执行器、静态经资源路径
2、样式隔离，shadow DOM 或者 scoped css 两种方式
3、渲染微应用
4、运行时沙箱，JS 沙箱、样式沙箱
5、合并沙箱传递出来的 生命周期方法、用户传递的生命周期方法、框架内置的生命周期方法，将这些生命周期方法统一整理，导出一个生命周期对象，供 single-spa 的 registerApplication 方法使用，这个对象就相当于使用 single-spa 时你的微应用导出的那些生命周期方法，只不过 qiankun额外填了一些生命周期方法，做了一些事情
6、给微应用注册通信方法并返回通信方法，然后会将通信方法通过 props 注入到微应用

#### loadApp内部是如何渲染微应用的

1.	拿到配置中的 container 和 render
2.	通过配置信息 拿到内部需要调用包装后的 render  (getRender)
3.	调用render

#### 运行时JS沙箱机制作用
JS 沙箱，通过 proxy 代理 window 对象，记录 window 对象上属性的增删改查
单例模式
直接代理了原生 window 对象，记录原生 window 对象的增删改查，当 window 对象激活时恢复 window 对象到上次即将失活时的状态，失活时恢复 window 对象到初始初始状态
多例模式
代理了一个全新的对象，这个对象是复制的 window 对象的一部分不可配置属性，所有的更改都是基于这个 fakeWindow 对象，从而保证多个实例之间属性互不影响
将这个 proxy 作为微应用的全局对象，所有的操作都在这个 proxy 对象上，这就是 JS 沙箱的原理

作用是保证每一个微应用运行在一个干净的环境中（JS 执行上下文独立、应用间不会发生样式污染）

#### 单例沙箱和多例沙箱的具体实现
单例沙箱 基于 Proxy 实现的单例模式下的沙箱，直接操作原生 window 对象，并记录 window 对象的增删改查，在每次微应用切换时初始化 window 对象；激活时：将 window 对象恢复到上次即将失活时的状态;失活时：将 window 对象恢复为初始状态

多例沙箱 通过 proxy 代理 fakeWindow 对象，所有的更改都是基于 fakeWindow，这点和单例不一样，从而保证每个 ProxySandbox 实例之间属性互不影响

