---
title: 页面性能
date: 2018-08-22 17:46:14
tags:
  - 页面性能
  - 浏览器缓存
---

## 提升页面的常用方法

- 资源压缩合并，减少http请求，开启gzip压缩
- 非核心代码异步加载
- 利用浏览器缓存
- 使用CDN
- 预解析DNS
- 域名收敛

``` html
<!-- off为关闭,ON为开启,页面中所有的a标签默认开启dns预解析，但是如果页面是https的，浏览器默认关闭预解析，这里最好开启一下 -->
<meta http-equiv="X-dns-prefetch-control" content="on" />
<!--如果不确定是http还是https连接的话建议如下写法 -->
<link rel="dns-prefetch" href="//prefetchhostname.com" />
  ```
<!-- more -->

### 异步加载

#### 方法

- 动态脚本加载（动态创建节点）
- defer
- async

#### defer、async区别

defer是在HTML解析完之后才会执行，如果是多个，则按照加载的顺序依次执行。

async加载完之后立即执行，如果是多个 ，执行顺序和加载顺序无关。

```html
<!-- defer1和async1文件内容很大-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>性能优化</title>
    <script src="./defer1.js" charset="utf-8" defer></script>
    <script src="./defer2.js" charset="utf-8" defer></script>
    <script src="./async1.js" charset="utf-8" async></script>
    <script src="./async2.js" charset="utf-8" async></script>
  </head>
  <body>
    <div class="">
      test
      <script type="text/javascript">
        console.log('write');
        document.write('<span>write</span>');
      </script>
      <script type="text/javascript">
        for (var i = 0; i < 3; i++) {
            console.log(i);
        }
      </script>
    </div>
  </body>
</html>
```

运行结果:

- write
- 1
- 2
- 3
- async2
- defer1
- defer2
- async1

### 浏览器缓存

 缓存是提升页面性能同时减少服务器压力的利器。

#### 分类

- 强缓存
- 协商缓存

##### 强缓存(直接拿缓存结果使用)

不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；

###### 强缓存相关的header

Expires: Wed, 22 Aug 2018 09:38:37 GMT

Cache-Control: Cache-Control:max-age=3600

Expires标识绝对时间，一般是服务下发的服务器绝对时间，它的值为一个绝对时间的GMT格式的时间字符串
Cache-Control是相对时间，在配置缓存的时候，以秒为单位，用数值表示。当值设为max-age=3600时，代表在在获取到资源之后，在3600s之内再次加载资源，就会命中强缓存，不会向服务器重新请求资源。
如果服务器将两个字段都下发，则以Cache-Control为准

###### 强缓存比较

其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容较客户端是否已经发生了更新呢？此时我们需要协商缓存策略。

##### 协商缓存(使用缓存文件之前先请求服务器看是否可以使用)

向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。

###### 协商缓存相关的header

第一组：
Last-Modified 上次修改的时间。当强缓存失效，客户端开始请求，携带Last-Modified-Since（值为服务器下发的
Last-Modified的值）
(问题是时间可能变了 但是内容可能没有变化)

Last-Modified-Since

Last-Modified和If-Modified-Since：当第一次请求资源时，服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。`Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT` 客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。

![协商缓存机制](协商缓存机制.png)

【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。总接起来是以下两点：

Ⅰ.某些服务端不能获取精确的修改时间
Ⅱ.文件修改时间改了，但文件内容却没有变

所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。

第二组：
Etag 服务器下发 ，当强缓存失效，客户端开始请求，携带If-None-Match（值为服务器下发的Etag的值）

If-None-Match

Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

![协商缓存机制-2](协商缓存机制-2.png)

两组之间对比：

首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
第三在优先级上，服务器校验优先考虑Etag

##### 浏览器缓存机制

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。主要过程如下：

<!-- ![浏览器缓存机制](页面性能.jpg) -->

![缓存机制](缓存机制.png)

### 域名收敛

如果你页面中引入的各种资源来自不同的域名，注意每增加一个域名,都会增加一次域名解析开销。 在复杂的国内移动互联网网络环境下，不同域名的解析速度可能会相差数十倍。 所以你需要有意识的收敛页面资源所需解析的域名数, 特别是会阻塞页面渲染的CSS,JS,Font资源。 很多性能糟糕页面究其原因或许会是引入的资源域名解析速度很慢或完全不能正确解析。在我们的实践中, 一个页面所产生的域名解析数不能超过5个。

参考： https://juejin.im/entry/58db1a20b123db199f53005e
