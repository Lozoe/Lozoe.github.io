---
title: 二叉树遍历
date: 2024-01-11 21:16:06
tags:
---

在 JavaScript 中，你可以使用递归或迭代的方式来实现二叉树的前序、中序和后序遍历。下面是使用递归方式实现的示例代码：


### 递归
```js
// 定义二叉树节点
class TreeNode {
  constructor(val, left, right) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

// 前序遍历
function preorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (node === null) return;
    
    result.push(node.val);
    traverse(node.left);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// 中序遍历
function inorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (node === null) return;
    
    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// 后序遍历
function postorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (node === null) return;
    
    traverse(node.left);
    traverse(node.right);
    result.push(node.val);
  }
  
  traverse(root);
  return result;
}

// 创建二叉树
const tree = new TreeNode(1);
tree.left = new TreeNode(2);
tree.right = new TreeNode(3);
tree.left.left = new TreeNode(4);
tree.left.right = new TreeNode(5);

// 测试
console.log(preorderTraversal(tree));   // 前序遍历结果：[1, 2, 4, 5, 3]
console.log(inorderTraversal(tree));    // 中序遍历结果：[4, 2, 5, 1, 3]
console.log(postorderTraversal(tree));  // 后序遍历结果：[4, 5, 2, 3, 1]
```

### 迭代


```js
function TreeNode(val, left, right) {
    this.val = (val === undefined ? 0 : val)
    this.left = (left === undefined ? null : left)
    this.right = (right === undefined ? null : right)
}
// 前序遍历
var preorderTraversal = function(root) {
    if (root === null) {
        return [];
    }
    const result = [];
    const stack = [];
    stack.push(root);
    while(stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);
        if (node.right !== null) {
            stack.push(node.right);
        }
        if (node.left !== null) {
            stack.push(node.left);
        }
    }
    return result;
};
// 中序遍历
var inorderTraversal = function (root) {
    const result = [];
    const stack = [];
    let current = root;
    while (current !== null || stack.length > 0) {
        while (current !== null) {
            stack.push(current);
            current = current.left;
        }
        current = stack.pop();
        result.push(current.val);
        current = current.right;
    }
    return result;
};
// 后续遍历
var postorderTraversal = function (root) {
    if (root === null) {
        return [];
    }
    const result = [];
    const stack = [];
    let current = root;
    let lastVisited = null;

    while (current !== null || stack.length > 0) {
        if (current !== null) {
            stack.push(current);
            current = current.left;
        } else {
            const peekNode = stack[stack.length - 1];
            if (peekNode.right !== null && lastVisited !== peekNode.right) {
                current = peekNode.right;

            } else {
                result.push(peekNode.val);
                lastVisited = stack.pop();
            }
        }
    }
    return result;
};

// 创建二叉树
const root = new TreeNode(1);
const node2 = new TreeNode(2);
const node3 = new TreeNode(3);

root.right = node2;
node2.left = node3;
// 层序遍历
const result1 = preorderTraversal(root);
const result2 = inorderTraversal(root);
const result3 = postorderTraversal(root);
// 打印结果
console.log(result1);
console.log(result2);
console.log(result3);
```